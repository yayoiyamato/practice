<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>$.Deferredの練習</title>
</head>
<body>
<h1>$.Deferredの練習</h1>
<button>click here in 3sec!</button>
</body>

<script src="https://code.jquery.com/jquery-3.5.1.min.js" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>

<script>

/*
 *  $.Deferred の練習
 */

'use strict';

/*
 *  基本の使い方
 *  ① deferredオブジェクトとpromiseオブジェクトの生成（deferredの状態：pending）
 *     処理のメインとなる部分ではdeferredを操作し、他の機能とやり取りする部分ではpromiseを渡すが基本
 *     deferredから特定のAPI(resolve/rejectなど)を通すことで、不正な状態操作をできないようにしている
 *     promiseは、deferredの状態が変わった時に行う処理を登録するためだけに使う
 *  ② done, failでdeferredに関数を登録
 *     then(resolveFunc, rejectFunc)を使えば同時に登録できる
 *     2つめの関数は省略可能で、指定しなければdoneと同じ動きになる
 *  ③ deferredが解決／却下される（deferredの状態：resolved／rejected）
 *  ④ ②で登録されていた関数が実行される
 * 
 *  ※ promiseとは、deferredの持っている機能のうち、状態を変化させる機能を使えなくしたオブジェクト
 *    promiseが使えるのはdone、fail、thenだけで、resolve/rejectは使えない
 */

// 3秒以内にボタンが押されたらresolveする関数
function testFunc() {
  const d = $.Deferred()
  $("button").click(() => d.resolve())
  setTimeout(() => d.reject(), 3000)
  return d.promise();
}

// testFunc().then(
//   () => alert("DONE!"),
//   () => alert("FAIL!")
// )

/*
 *  done/fail関数の中でpromise生成する
 *  ※ thenのfail側を書かなかったら、rejectのとき何も実行せずに次の then に移る
 *  　 その場合、前のpromiseの状態を引き継ぐので次にfailの処理を書いているところまで処理がとばされる
 */
testFunc().then(
  () => {
    console.log("DONE!1")
    return testFunc()
  }
).then(
  () => {
    console.log("DONE!2")
    return testFunc()
  }
).then(
  () => {
    console.log("DONE!3")
  },
  () => {
    console.log("FAIL!")
  }
)

</script>

</html>